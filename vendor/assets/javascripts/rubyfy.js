// More info: https://github.com/calebkm/rubyfy
if(this.Rubyfy||(this.Rubyfy={}),Rubyfy.classes="Array Object String".split(" "),Rubyfy.Array="any compact is_empty first last".split(" "),Rubyfy.String="capitalize downcase is_blank".split(" "),Rubyfy.Object="any is_empty keys vals".split(" "),Rubyfy.compact=function(y){if(Rubyfy.defined(y,"compact"))return y.filter(y=>null!=y)},Rubyfy.first=function(y){if(Rubyfy.defined(y,"first"))return y[0]},Rubyfy.last=function(y){if(Rubyfy.defined(y,"last"))return y[y.length-1]},Rubyfy.keys=function(y){if(Rubyfy.defined(y,"keys"))return Object.keys(y)},Rubyfy.vals=function(y){if(Rubyfy.defined(y,"vals"))return Object.values(y)},Rubyfy.any=function(y){if(Rubyfy.defined(y,"any"))return!Rubyfy.is_empty(y)},Rubyfy.is_empty=function(y){if(Rubyfy.defined(y,"is_empty")){if(Rubyfy.is_array(y))return 0===Rubyfy.compact(y).length;if(Rubyfy.is_object(y))return 0===Object.keys(y).length}},Rubyfy.capitalize=function(y){if(Rubyfy.defined(y,"capitalize"))return y.charAt(0).toUpperCase()+y.slice(1).toLowerCase()},Rubyfy.downcase=function(y){if(Rubyfy.defined(y,"downcase"))return y.toLowerCase()},Rubyfy.is_blank=function(y){if(Rubyfy.defined(y,"is_blank"))return""===y.trim()},Rubyfy.defined=function(y,t){if(null!=y){const f=Rubyfy.class_of(y);if(f&&Rubyfy[f]&&Rubyfy[f].includes(t))return!0;throw new Error(`Rubyfy does not define a function \`${t}\` for ${Rubyfy.capitalize(f)}`)}throw new Error(`Cannot call Rubyfy \`${t}\` on ${y}`)},Rubyfy.class_of=function(y){return Rubyfy.is_array(y)?"Array":Rubyfy.is_string(y)?"String":Rubyfy.is_object(y)?"Object":typeof y},Rubyfy.is_array=(y=>Array.isArray(y)),Rubyfy.is_string=(y=>"string"==typeof y||y.constructor===String||"[object String]"===Object.prototype.toString.call(y)),Rubyfy.is_object=(y=>"object"==typeof y&&null!==y&&!Rubyfy.is_array(y)&&!Rubyfy.is_string(y)),Rubyfy.no_r||(void 0===this.R?(this.R=Rubyfy,this._R_IS_DEFINED_=!0):console.warn("Unable to assign Rubyfy shorthand `R` because it's already defined. You can still use `Rubyfy` explicitly.")),!Rubyfy.no_prototypes)for(let klass of Array.from(Rubyfy.classes))(klass=>Array.from(Rubyfy[klass]).map(func=>(function(func){return void 0===eval(klass).prototype[func]?Object.defineProperty(eval(klass).prototype,func,{value(){return Rubyfy[func](this)}}):console.warn(`Rubyfy attempted to define \`${klass}#${func}\` but it looks like ${klass}.prototype.${func} has already been defined. You can still use the Rubyfy version of \`${func}\` by calling it explicitly with \`${this._R_IS_DEFINED_?"R":"Rubyfy"}.${func}()\``)})(func)))(klass);